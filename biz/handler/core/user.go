// Code generated by hertz generator.

package core

import (
	"context"
	"time"

	"douyin_backend/biz/config"
	"douyin_backend/biz/dal/mysql"
	core "douyin_backend/biz/hertz_gen/model/core"
	"douyin_backend/biz/hertz_gen/model/data"
	"douyin_backend/biz/model"
	"douyin_backend/biz/mw/jwt"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"golang.org/x/crypto/bcrypt"
)

var Expired = time.Minute * time.Duration(config.Cfg.Jwt.Expired)

// UserRegister .
// @router /douyin/user/register/ [POST]
func UserRegister(ctx context.Context, c *app.RequestContext) {
	var err error
	var req core.UserRegisterRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(core.UserRegisterResponse)
	responseFail := func(code int32, msg string) {
		resp.StatusCode, resp.StatusMsg = code, &msg
		c.JSON(consts.StatusOK, resp)
	}

	ulen, plen := len(req.Username), len(req.Password)
	if ulen > 32 || plen > 32 || ulen < 1 || plen <= 5 {
		responseFail(-1, "invalid username or password length")
		return
	}
	// Check if username exist in database
	if user, _ := mysql.FindUserByName(req.Username); user != nil {
		responseFail(-1, "username already exists")
		return
	}

	// generate hash for password
	hash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		hlog.Debug(err)
		responseFail(-1, "internal error")
		return
	}

	user, err := mysql.CreateUser(&model.User{Username: req.Username, Password: string(hash)})
	if err != nil {
		hlog.Debug(err)
		responseFail(-1, "internal error")
		return
	}
	token, err := jwt.SignUser(user.ID, Expired)
	if err != nil {
		hlog.Debug(err)
		responseFail(-1, "internal error")
		return
	}
	resp.UserID = user.ID
	resp.StatusCode = 0
	resp.Token = *token
	c.JSON(consts.StatusOK, resp)
}

// UserLogin .
// @router /douyin/user/login/ [POST]
func UserLogin(ctx context.Context, c *app.RequestContext) {
	var err error
	var req core.UserLoginRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(core.UserLoginResponse)
	dbUser, err := mysql.FindUserByName(req.Username)
	if err != nil || bcrypt.CompareHashAndPassword([]byte(dbUser.Password), []byte(req.Password)) != nil {
		msg := "wrong username or password"
		resp.StatusCode, resp.StatusMsg = -1, &msg
		c.JSON(consts.StatusOK, resp)
		return
	}
	token, err := jwt.SignUser(dbUser.ID, Expired)
	if err != nil {
		msg := "internal error"
		resp.StatusCode, resp.StatusMsg = -1, &msg
		c.JSON(consts.StatusInternalServerError, resp)
		return
	}
	resp.Token = *token
	resp.UserID = dbUser.ID
	resp.StatusCode = 0
	c.JSON(consts.StatusOK, resp)
}

// UserInfo .
// @router /douyin/user/ [GET]
func UserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req core.UserRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(core.UserResponse)
	user, err := mysql.UserInfoByID(req.UserID)
	if err != nil {
		msg := "user not found"
		resp.StatusCode, resp.StatusMsg = -1, &msg
		c.JSON(consts.StatusOK, resp)
		return
	}
	// TODO(add follower count)
	resp.User = &data.User{
		ID:   user.ID,
		Name: user.Username,
	}
	c.JSON(consts.StatusOK, resp)
}
